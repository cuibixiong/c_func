template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

class S
{
    public:
        static S& getInstance()
        {
            static S    instance; // Guaranteed to be destroyed.
                                  // Instantiated on first use.
            return instance;
        }
    private:
        S() {}                    // Constructor? (the {} brackets) are needed here.

        // C++ 03
        // ========
        // Don't forget to declare these two. You want to make sure they
        // are unacceptable otherwise you may accidentally get copies of
        // your singleton appearing.
        S(S const&);              // Don't Implement
        void operator=(S const&); // Don't implement

        // C++ 11
        // =======
        // We can use the better technique of deleting the methods
        // we don't want.
    public:
        S(S const&)               = delete;
        void operator=(S const&)  = delete;

        // Note: Scott Meyers mentions in his Effective Modern
        //       C++ book, that deleted functions should generally
        //       be public as it results in better error messages
        //       due to the compilers behavior to check accessibility
        //       before deleted status
};



struct fragment
  {
    std::string name;
    uint64_t ts;

    bool edge;

    // sort by ts
    bool operator <(const fragment p) const
    {
      return ts < p.ts;
    }
  };
  
static inline std::ostream& operator<<(std::ostream& out, const ProfileData& p)
{
  out << p.coords_ << std::endl;
  out << p.ip_ << std::endl;
  out << p.event_type_ << std::endl;
  out << "cycle:" << p.cycle_ << std::endl;
  out << "counter:" << p.counter_ << std::endl;
  out << "counter val:" << p.counter_val_ << std::endl;
  return out;
}

class HW {
 public:
  static void CreateInstance(DTU_HWAPI_USE mach, uint64_t ip_mask)
  {
    GetInstanceImpl(mach, ip_mask);
  }

  static void CreateInstance(DTU_HWAPI_USE mach, std::string &ip_layout)
  {
    GetInstanceImpl(mach, dtu_convert_layout2mask(mach, ip_layout.c_str()));
  }

  static HW& GetInstance() {
    return GetInstanceImpl(mach_, ip_mask_);
  }

  static HW &GetInstanceImpl(DTU_HWAPI_USE mach, uint64_t ip_mask) {
    static HW instance_;

    if (instance_.GetAPI() == nullptr) {
      dtu_get_hwapi(DTU_HWAPI_TARGET_API_VERSION_MAJOR,
                  DTU_HWAPI_TARGET_API_VERSION_MINOR,
                  DTU_HWAPI_TARGET_API_VERSION_REVISION, &hw_access_api_);

      instance_.GetAPI()->initialize(mach);
      dtu_set_ip_mask(ip_mask);

      mach_ = mach;
      ip_mask_ = ip_mask;

      // TODO
      instance_.GetAPI()->get_device_attr(-1, DTU_HWAPI_ATTR_DEV_CNT, &num_of_dev_);
      instance_.GetAPI()->get_device_attr(0, DTU_HWAPI_ATTR_CLUSTER_CNT, &num_of_cluster_);
      instance_.GetAPI()->get_device_attr(0, DTU_HWAPI_ATTR_SIP_CNT, &num_of_sip_);
      instance_.GetAPI()->get_device_attr(0, DTU_HWAPI_ATTR_ODMA_CNT, &num_of_odma_);
      instance_.GetAPI()->get_device_attr(0, DTU_HWAPI_ATTR_CDMA_CNT, &num_of_cdma_);
      instance_.GetAPI()->get_device_attr(0, DTU_HWAPI_ATTR_SDMA_CNT, &num_of_sdma_);
    }

    return instance_;
  }

  ~HW() {
    hw_access_api_->finalize();
  }

  Status ReadRegister(Coords &coords, uint32_t offset, void *val);
  Status WriteRegister(Coords &coords, uint32_t offset, void *val);
  Status ReadMemory(Coords &coords, uint64_t addr, void *buf, size_t sz);
  Status WriteMemory(Coords &coords, uint64_t addr, void *buf, size_t sz);
  uint32_t RegOffset(const std::string &reg_name, const std::string &ip_name);
  DTU_HWAPI_TARGET_API *GetAPI() { return hw_access_api_; }

public:
  DISALLOW_COPY_AND_ASSIGN(HW);

  int32_t num_of_dev() { return num_of_mc_ ; }
  int32_t num_of_cluster() { return num_of_mc_ ; }
  int32_t num_of_sip() { return num_of_mc_ ; }

  int32_t num_of_odma() { return num_of_odma_; }
  int32_t num_of_cdma() { return num_of_cdma_; }
  int32_t num_of_sdma() { return num_of_sdma_; }

  int32_t num_of_mc() { return num_of_mc_; }
  int32_t num_of_pmc() { return num_of_pmc_; }

private:
  HW() {};

private:
  static DTU_HWAPI_TARGET_API *hw_access_api_;

  static DTU_HWAPI_USE mach_;
  static uint64_t ip_mask_;

  static int32_t num_of_odma_;
  static int32_t num_of_cdma_;
  static int32_t num_of_sdma_;

  static int32_t num_of_dev_;
  static int32_t num_of_cluster_ ;
  static int32_t num_of_sip_;

  // TODO
  static const int32_t num_of_mc_;
  static const int32_t num_of_pmc_;
};

// note: this implementation does not disable this overload for array types
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args)
{
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}


class variant_visitor : public boost::static_visitor<std::string const &> {
+  public:
+   std::string const& operator()(const double &i) { output += std::to_string(i); return output;}
+   std::string const& operator()(const int32_t &i) { output += std::to_string(i); return output;}
+   std::string const& operator()(std::string &i) { return std::move(i); }
+   std::string output = "";
+ };
int main()
{
  variant_visitor vis;
  auto v = boost::apply_visitor(vis, arg.second);
}
}

 sort(myVec.begin(), myVec.end(), [](const Foo &foo1, const Foo &foo2)
    {                                                 // 排序三：使用 lambda 的方式进行排序，排序的方法和 Foo::decrease 一样
        if (foo1.a > foo2.a)
        {
            return true;
        }
        else if (foo1.a == foo2.a)
        {
            return foo1.b > foo2.b;
        }
        return false;
    }   );
